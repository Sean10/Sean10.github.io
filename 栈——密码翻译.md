---
title: 栈——密码翻译
tags: [栈]
date: 2015-11-18 12:43:00
categories: 算法
---

[题目链接](http://dsalgo.openjudge.cn/201409week3/2/)
总时间限制: 1000ms 内存限制: 65536kB
描述
在情报传递过程中，为了防止情报被截获，往往需要对情报用一定的方式加密，简单的加密算法虽然不足以完全避免情报被破译，但仍然能防止情报被轻易的识别。我们给出一种最简的的加密方法，对给定的一个字符串，把其中从a-y,A-Y的字母用其后继字母替代，把z和Z用a和A替代，则可得到一个简单的加密字符串。

输入
第一行是字符串的数目n。
其余n行每行一个字符串。
输出
输出每行字符串的加密字符串。
样例输入
```
1
Hello! How are you!
```
样例输出
```
Ifmmp! Ipx bsf zpv!
```

最近重新开始练算法了，好多基础用法都忘了，现在重新熟悉一下，先从OpenJudge做起。

这道题严格意义上应该题目叫简单凯撒密码翻译。题目理解很简单，不过对于scanf的用法需要注意，在%s格式时，遇到空格就会结束输入，这里可以用gets()和scanf("%[^\n]",h)来解决这个问题。

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    //freopen("in.txt","r",stdin);
    char h[1000];
    int n;
    scanf(" %d",&n);
    getchar();
    for(int k = 0;k < n;k++){
        //getchar();
        gets(h);
        //printf("%s\n",h);
        int len=strlen(h);
        for(int i = 0;i < len;i++){
            if((h[i] >= 'a' && h[i] < 'z') ||( h[i] >= 'A' && h[i] < 'Z')){
                h[i]+=1;
            }
            else if(h[i] == 'z'){
                h[i] = 'a';
            }
            else if(h[i] == 'Z'){
                h[i] = 'A';
            }
        }
        printf("%s\n",h);
    }
    return 0;
}
```