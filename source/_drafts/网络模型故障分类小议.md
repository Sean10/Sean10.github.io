---
title: 网络模型故障分类小议
subtitle: tech
date: 2023-05-29 23:05:39
updated:
tags: [分布式, 故障]
categories: [专业]
---


> 系统模型 (System Model), 是描述系统的特性的一些假设, 基于这些假设才可以设计出各种各样的分布式系统. 这些假设包括但不限于:
> 
> 每个节点的计算能力以及它们的失效模式
> 节点间通信的能力以及是否可能失效
> 整个系统的属性, 比如时序等等

> 其中每一点下面都会讲到. 如果一个系统模型是基于最弱的假设的, 比如节点可能出现硬件错误、网络拥塞或断开以及可能遭到恶意攻击等等, 那基于这样的系统模型的分布式系统可以运行在各种各样的环境下, 因为它的容错极高.

最极端的是拜占庭故障, 任何异常都会出现, 且不可靠. 针对此类场景的算法现实生活中暂时不存在. 最常用的还是 crash-recovery 模型.

进程可发生各种类型的错误，错误可以大致分为：

良性错误：进程崩溃，节点崩溃，网络故障；
拜占庭（Byzantine）故障：随机方式出现故障，例如出现漏洞，被挟持并以任意方式向正确进程/节点发送数据，阻止正确进程达成一致。
　　Byzantine Generals Problem 由Lamport 1982年提出，考虑信道安全，但是出错节点发送的信息任意。在区块链中，考虑此类别的问题是必要的。


> 
> 
> 　通信健壮：只要进程非失败，消息虽会被无限延迟，但最终会被送达，并且消息仅会被送达一次（无重复），使用TCP协议有效保证通信的健壮。
> 
> 　　同步系统中的共识问题已被证明可以实现，消息可以分为“口头的”和“正式的”，即消息是否经过签名。Lamport【1982】讨论了3个进程相互发送未签名消息，若有一个进程出现BFT故障，则无法达成共识，并延伸到了N≤3f的情况。Pease等人证明了N≤3f下BFT共识的不可能性（证明未细看），并提出了在N>3f+1时的解决方案。
进行多少轮通信和发送多少消息（消息的长度）非常重要。通信阶段数影响终止的时间，消息的长度影响带宽的利用率，也影响时间。

　　Fischer、Lynch【1982】证明，如果允许BFT故障，则任何确定性的解决共识问题的算法至少需要f+1轮消息传递（证明未看）。


> 绕过不可能性的三个方法（考虑部分同步系统 partially synchronous system，使共识问题可以被解决 Dwork et al.【1988】）：

-   故障屏蔽：屏蔽进程故障，使进程可以恢复，利用持久存储保留足够的信息；
-   使用故障检测器：使用“不完美”的故障检测器，即被怀疑的进程依然可以行动，使用故障检测器是将异步系统转化到同步系统；
-   使用随机化达成共识：引入一个关于进程行为的可能性元素，使得敌人不能有效地来实施他们的阻碍战术。Canetti、Rabin【1993】提出一种概率算法可以解决该问题。

> 
> 迫于现实中的场景, 存在同步/异步系统模型
> 
> 总的来说，一共存在三种类型的通信模型，分别是同步模型、异步模型与部分同步模型。
> 
> （1） 同步模型（Synchronous model）
> 
> 在同步模型中，所有节点之间的消息通信都存在一个已知的延迟上界，并且不同节点处理事务的相对速度差值有一个已知上界。同步模型是一个非常理想的通信模型，在现实生活中几乎不可见，但是在分布式系统的理论研究中却发挥着及其重要的作用，许多早期的分布式一致性算法都是在同步网络假设下设计的。
> 
> （2） 异步模型（Asynchronous model）
> 
> 系统中各个节点可能存在较大的时钟差异；同时消息传输时间是任意长的；各节点对消息进行处理的时间也可能是任意长的。这就造成无法判断某个消息迟迟没有被响应是哪里出了问题（节点故障还是传输故障）。现实生活中的系统往往都是异步系统。
> 
> 在异步模型中，上述的假设上界都不存在，因此异步模型比较符合现实的互联网环境。异步与同步相比，是一种更通用的情况。一个适用于异步系统的算法，也能被用于同步系统，但是反过来并不成立。在异步模型中设计一个正确的共识算法已经被证明是不可能的。
> 
> （3） 部分同步模型（Partial Synchronous model）
> 
> 部分同步模型是界于同步模型与异步模型之间的一种通信模型，于1988年由Dwork, Lynch等人在论文[1]中提出。该模型中假设存在一个全局稳定时钟GST（Global Stabilization Time），在GST之前整个系统可能处于异步状态，但是在GST之后，整个系统可以恢复到同步状态。部分同步模型的时序假设比较贴合现实世界中对共识算法的需求，即共识总是可以在同步状态下完成，然而一旦网络出现问题，共识可能会进入一段时间的阻塞，直至网络恢复正常。

进程间的消息通讯、传输延时是有上界的；只有在网络过载、网络分区故障时，才没有上界；
每个进程的处理速度是确定的；只有在发生GC、磁盘IO阻塞等异常情况时，每个进程的处理速度才不可确定。
每个机器上的时钟我们可以认为是基本同步的，比如我们可以使用NTP来同步机器时间，而且多数机器上有独立的时钟芯片，我们也可以粗略认为各个机器上时间流逝的速度是相同的。但是严格要求时序的系统除外。


> 
> 定理所依赖的系统模型很简单:
> 
> 节点只会因为 crash 而失效 (非拜占庭失效)
> 网络是可靠的, 只要进程非失败，消息虽会被无限延迟，但最终会被送达；并且消息仅会被送达一次 (无重复)
> 异步的时序模型, 与同步通信的最大区别是没有时钟、不能时间同步、不能使用超时、不能探测失败、消息可任意延迟、消息可乱序
> 
>在现实中，一般网络会使用 TCP 协议 (保证了消息健壮、不重复、不乱序)，每个节点都有 NTP 时钟同步 (可以使用超时), 如 FLP 定理的系统模型这样的异步场景相对比较少. 但是也还是存在一定的场景.
> 
> FLP 在这样的系统模型下给出了一个很吃鸡的结论: 在异步通信场景，即使只有一个进程失败，也没有任何 (确定性) 算法能保证非失败进程达到一致性.
> 
> 也就是说, 解决共识问题的算法必须在不存在消息传递边界的情况下放弃强一致 (safety) 或者可用性 (liveness)。

# 故障探测

在分布式系统中，自然状态下是一个异步网络，因此故障探测很难做到同时具有完整性和准确性。 因此我们可以其大致将这两个分为强弱之分：

强完整性：每一个宕机的进程最终都能被每个正常的进程发现；
弱完整性：每一个宕机的继承最终只能被一些正常的进程发现；
强准确性：正常的进程不会被归为宕机状态；
弱准确性：正常的进程中的一部分从来不会被归为宕机状态；
完整性相对来说比较好实现，准确性相对来说比较难实现，因为在异步网络中，很难分辨到底是真的 宕机了还是网络延时了。

[分布式编程中的故障探测 — 源代码](https://lrita.github.io/2017/10/30/failure-detect-in-distributed-programming/)

[网络游戏同步模型\-腾讯云开发者社区\-腾讯云](https://cloud.tencent.com/developer/article/1748823)

[帧同步和状态同步该怎么选（上） \- 知乎](https://zhuanlan.zhihu.com/p/104932624)

游戏的状态同步, 其实也算是一种基于分布式的实现? 毕竟实际用户都在不同地点.

# 共识

 所谓共识 (Consensus) 问题, 就是相互独立的节点之间如何达成一项决议的问题。通俗来说, 如果多个相互独立的节点都认同同一个结果, 那他们就达成了共识. 形式化的描述就是:

-   认同 (agreement): 一个决议过程中所有 N 个节点都认同一个结果
-   合法 (validity): 该结果必须由 N 个节点中的节点提出
-   可结束 (termination): 决议过程在一定时间内结束，不会无休止地进行下去

> 这个听上去很简单, 但是在比较弱的系统模型下, 有很多问题会导致共识是很难达成的. 比如如果网络中存在消息延时、丢失，节点间消息传递; 亦或者是节点存在 crash 的情况. 在这些假设下, 如何达成共识, 才是真正对现实中的分布式系统有价值的讨论.


线性一致性
顺序一致性
最终一致性
	因果一致性