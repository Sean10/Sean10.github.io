---
title: 网络编程面试小结
date: 2018-04-02 19:46:49
updated:
tags: [网络, TCP, IP]
categories: [专业]
---

# HTTPS工作原理

这三种套接为流式套接字（SOCK-STREAM）、数据报套接字（SOCK-DGRAM）和原始套接字（SOCK-RAW）。

# TCP与UDP

TCP的流式，老是忘记，然后看到其他人遇到的所谓"粘包"问题就老是想不起来……最简单的办法按照所说的，直接ping pong关闭那个句柄，直接开新的就好了。

a socket can not be reused once the connection is closed, i.e. you can not call socket.connect() on a closed socket.

突然想到，创建的一个socket不能在关闭后再使用吗，为什么呢？

只是建立了Socket对象后，底层lsof看到的是这样呈现的，还没有变成一个unix 

python3   20871 root    3u  IPv4             265824       0t0      TCP localhost:65432 (LISTEN)
python3   20871 root    4u  IPv4             267235       0t0      TCP localhost:65432->localhost:53966 (CLOSE_WAIT)

 sock    0,9       0t0   267632 protocol: TCP

在执行了connect之后，就立马变成了一个established的socket。

但是在服务端，此时还没有显示出这个socket……所以这样来说，实际上connect完成的操作是只要那边有监听，然后内核或者别的什么会直接和客户端完成三次握手，然后将这个socket留在缓冲区或者内核里，等待服务端去取的嘛……

服务端bind完成，如果不执行listen的话，也是和上面那个一样。

建立了socket对象的时候，是不是还没从本机申请到随机动态端口，从而向外发送请求呢？

这个时候似乎是根据传入的协议是Stream还是udp等，在内核中申请INET对象

linux内核中会维护两个队列，这两个队列的长度都是有限制且可以配置的，当客户端发起connect()请求后，服务端收到syn包后将该信息放入sync队列，之后客户端回复ack后从sync队列取出，放到accept队列，之后服务端调用accept()方法会从accept队列取出生成socket。
如果客户端发起sync请求，但是不回复ack，将导致sync队列满载，之后会拒接新的连接。如果客户端发起ack请求后，服务端一直不调用，或者调用accept队列太慢，将导致accept队列满载，accept队列满了则收到ack后无法从syn队列移出去，导致syn队列也会堆积，最终拒绝连接。所以服务端一般会将accept单独起一个线程执行，避免accept太慢导致数据丢弃。当然accept()方法也有阻塞和非阻塞两种，当accept队列为空的时候阻塞方法会一直等待，非阻塞方法会直接返回一个错误码。

作者：pigpdong
链接：https://juejin.im/post/5cb9b862f265da03867e4cda
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## TCPServer

在使用python的TCPServer的过程中，看到有人使用了makefile的方式，将内容通过一个临时文件来读写，这只是一个demo，在我修改代码尝试使用的过程中，发现，由于他是通过文件来实现的，文件的缓冲区不flush，我的服务端是读不到内容的，而缓冲区清空需要服务端返回内容，但是我服务端需要读取完整的文本内容，使用的是Read()，而不是原先的readline（）。（欸，这么来说的话，其实可能也不是read的原因？但是我从finish那里看到这个时候才执行flush的操作呀）


## 挥手会遇到的坑

在 Client 端调用 socket.close() 时，首先会往对端(即 Server 端)发送一个 FIN 包，接着将自身的状态置为 FIN_WAIT1 ，此时主动关闭端(即 Client 端)处于持续等待接收对端的响应 FIN 包的 ACK 回应状态，此时对端的状态是处于 ESTABLISHED ，一旦收到了 Client 发来的 close 连接请求，就回应一个 FIN 包，表示收到该请求了，并将自身状态置为 CLOSE_WAIT，这时开始等待 Server 端的应用层向 Client 端发起 close 请求。

这时 Client 端一旦收到 Server 端对第一个 FIN 包的回应 ACK 就会将进入下一个状态 FIN_WAIT_2 来等待 Server 发起断开连接的 FIN 包。在FIN_WAIT_1 的 time_wait 中， Server 端会发起 close 请求，向 Client 端发送 FIN 包，并将自身状态从 CLOSE_WAIT 置为 LAST_ACK ，表示 Server 端的连接资源开始释放了。同时 Client 端正处于 FIN_WAIT2 状态，一旦接收到 Server 端的 FIN 包，则说明 Server 端连接已释放，接着就可以释放自身的连接了，于是进入 TIME_WAIT 状态，开始释放资源，在经过设置的 2个 MSL 时间后，状态最终迁移到 CLOSE 说明连接成功关闭，一次 TCP 4次挥手 关闭连接的过程结束。

[关于关闭 Socket 的一些坑 \| LexusLee's Blog](https://lexuslee.me/2017/09/06/close-socket/)

# Reference
1. [HTTPS工作原理和TCP握手机制](https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html)
