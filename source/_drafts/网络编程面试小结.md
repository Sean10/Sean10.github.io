---
title: 网络编程面试小结
date: 2018-04-02 19:46:49
updated:
tags: [网络, TCP, IP]
categories: [专业]
---

# HTTPS工作原理

这三种套接为流式套接字（SOCK-STREAM）、数据报套接字（SOCK-DGRAM）和原始套接字（SOCK-RAW）。

# TCP与UDP

TCP的流式，老是忘记，然后看到其他人遇到的所谓"粘包"问题就老是想不起来……最简单的办法按照所说的，直接ping pong关闭那个句柄，直接开新的就好了。

a socket can not be reused once the connection is closed, i.e. you can not call socket.connect() on a closed socket.

突然想到，创建的一个socket不能在关闭后再使用吗，为什么呢？

只是建立了Socket对象后，底层lsof看到的是这样呈现的，还没有变成一个unix 

python3   20871 root    3u  IPv4             265824       0t0      TCP localhost:65432 (LISTEN)
python3   20871 root    4u  IPv4             267235       0t0      TCP localhost:65432->localhost:53966 (CLOSE_WAIT)

 sock    0,9       0t0   267632 protocol: TCP

在执行了connect之后，就立马变成了一个established的socket。

但是在服务端，此时还没有显示出这个socket……所以这样来说，实际上connect完成的操作是只要那边有监听，然后内核或者别的什么会直接和客户端完成三次握手，然后将这个socket留在缓冲区或者内核里，等待服务端去取的嘛……

服务端bind完成，如果不执行listen的话，也是和上面那个一样。

建立了socket对象的时候，是不是还没从本机申请到随机动态端口，从而向外发送请求呢？

这个时候似乎是根据传入的协议是Stream还是udp等，在内核中申请INET对象

linux内核中会维护两个队列，这两个队列的长度都是有限制且可以配置的，当客户端发起connect()请求后，服务端收到syn包后将该信息放入sync队列，之后客户端回复ack后从sync队列取出，放到accept队列，之后服务端调用accept()方法会从accept队列取出生成socket。
如果客户端发起sync请求，但是不回复ack，将导致sync队列满载，之后会拒接新的连接。如果客户端发起ack请求后，服务端一直不调用，或者调用accept队列太慢，将导致accept队列满载，accept队列满了则收到ack后无法从syn队列移出去，导致syn队列也会堆积，最终拒绝连接。所以服务端一般会将accept单独起一个线程执行，避免accept太慢导致数据丢弃。当然accept()方法也有阻塞和非阻塞两种，当accept队列为空的时候阻塞方法会一直等待，非阻塞方法会直接返回一个错误码。

作者：pigpdong
链接：https://juejin.im/post/5cb9b862f265da03867e4cda
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# Reference
1. [HTTPS工作原理和TCP握手机制](https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html)
