---
title: Linux多线程服务端编程note
date: 2018-04-04 22:25:46
updated:
tags: [Linux, 多线程, C++]
categories: [专业]
---

# 线程安全的对象生命期管理

## 同步原语（synchronization primitives）
事件是一种同步原语，
具有下述操作：
* wait
* set
* clear

基本的进程线程同步互斥控制机制
1. 临界区 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
2. 互斥量 为协调一起对一个共享资源的单独访问而设计的。
3. 信号量 为控制一个具备有限数量用户资源而设计。
4. 事件 用来通知线程有一些事件已发生，从而启动后继任务的开始

<!--more-->

### 临界区（Critical Section）

确保在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。假如有多个线程试图同时访问临界区，那么在有一个线程进入后其他任何试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程能够继续抢占，并以此达到用原子方式操作共享资源的目的。

临界区包含两个操作原语： EnterCriticalSection（） 进入临界区 LeaveCriticalSection（） 离开临界区

### 互斥量（Mutex）

　　互斥量跟临界区很相似，只有拥有互斥对象的线程才具备访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不但仅能够在同一应用程式不同线程中实现资源的安全共享，而且能够在不同应用程式的线程之间实现对资源的安全共享。

互斥量包含的几个操作原语：
*　CreateMutex（） 创建一个互斥量
*　OpenMutex（） 打开一个互斥量
*　ReleaseMutex（） 释放互斥量
*　WaitForMultipleObjects（） 等待互斥量对象

### 信号量（Semaphores）

　　信号量对象对线程的同步方式和前面几种方法不同，信号允许多个线程同时使用共享资源，这和操作系统中的PV操作相同。他指出了同时访问共享资源的线程最大数目。他允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。在用CreateSemaphore（）创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数配置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就能够发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可用资源计数加1。在任何时候当前可用资源计数决不可能大于最大资源计数。

## 对象构造线程安全

>唯一要求是在构造期间不要泄露this指针


# Reference
1. [《Linux多线程服务端编程》]
2. [C++中四种进程或线程同步互斥的控制方法](https://blog.csdn.net/zhu2695/article/details/51148272)
3. [C++ 并发编程（二）：Mutex（互斥锁）](https://segmentfault.com/a/1190000006614695)
4. [C++11 并发指南三(std::mutex 详解)](http://www.cnblogs.com/haippy/p/3237213.html)
