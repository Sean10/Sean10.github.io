---
title: 死锁检测初探
subtitle: tech
date: 2023-06-02 23:33:42
updated:
tags: [死锁]
categories: [专业
---

> 
> OceanBase 数据库锁机制的死锁
> 锁机制的实现会导致死锁，死锁是指对于资源的循环依赖，举例来说，当事务 A 与事务 B 同时获取资源 C 与 D 的情况下，若事务 A 优先获取到资源 C 并去获取资源 D；而事务 B 优先获取到资源 D 并去获取资源 C。此时若没有任何人愿意放弃自己已经获取到的资源，就没有事务可以正常结束。
> 
> 基于超时的死锁解决
> OceanBase 数据库 V3.2 版本之前，未包含主动死锁检测的能力。因此我们主要是依赖超时回滚机制来解决业务逻辑上的死锁。
> 
> 存在三种超时机制用来解决对应的问题：
> 
> 锁超时机制：配置项名称为 ob_trx_lock_timeout，默认为语句超时时间，若加锁等待超过锁超时时间，则会回滚对应的语句，并返回锁超时对应的错误码。此时，由于某一个循环依赖中的资源依赖已经消失，因此就不再存在死锁。以事务 B 获取资源 C 超时为例，只要事务 B 结束，则事务 A 就可以获取到对应的资源 D。
> 
> 语句超时机制：配置项名称为 ob_query_timeout，默认为 10s，若加锁等待超过语句超时时间，则会回滚对应的语句，并返回语句超时对应的错误码。此时，由于某一个循环依赖中的资源依赖已经消失，因此就不再存在死锁。以事务 B 获取资源 C 超时为例，只要事务 B 结束，则事务 A 就可以获取到对应的资源 D。
> 
> 事务超时机制：配置项名称为 ob_trx_timeout，默认为 86400s，若加锁等待超过事务超时时间，则会回滚对应的事务，并返回语句事务对应的错误码。由于某一个循环依赖中的资源依赖已经消失，因此就不再存在死锁。以事务 B 超时为例，由于事务 B 结束，事务 A 就可以获取到对应的资源 D。
> 
> 主动死锁检测
> 从 OceanBase 数据库 V3.2 版本开始，除了以上基于超时的死锁解决机制，我们还实现了主动死锁检测机制。
> 
> 目前 OceanBase 数据库实现的死锁检测称为 LCL（Lock Chain Length）死锁检测方案，是一种基于优先级的多出度分布式死锁检测方案，OceanBase 数据库的死锁检测算法可以保证不误杀或多杀事务。
> 
> 基于优先级是指，在互相形成死锁的多个事务中，LCL 死锁检测方案总是倾向于杀掉其中优先级最低的事务来解除死锁，目前在死锁检测中事务的优先级指标主要为事务的开启时间，越晚开启的事务具有越低的优先级。
> 
> 多出度是指，每一个事务都可以同时等待超过一个的其他事务。
> 
> 分布式死锁检测是指，每一个代表事务进行死锁检测的节点仅知道该节点自身的依赖信息，在不需要全局的锁管理器的情况下即可探测节点间的死锁。
> 
> 实现原理
> 一个分布式事务为提高执行效率通常需要同时访问多个分区的数据，并可能同时发现存在多个锁冲突事件，此时为提高死锁检测的效率，可以描述出一个事务同时等待多个事务的单向依赖的有向边，称为多出度。
> 
> 常见的死锁检测方案多采用路径推动算法（path-pushing algorithm），这种算法应用在多出度场景下大多存在多杀以及误杀的问题。LCL 死锁检测方案采用的是一种经过特殊设计的边跟踪算法（edge-chasing algorithm），在 LCL 死锁检测方案中，每个节点维护两个状态，分别称为深度值以及令牌值，为防止多杀，一个节点维护的令牌值数量不能多于一个，令牌值之间可以比较，并使大的令牌值覆盖小的令牌值，如此可以保证在一个环路中，只有最大令牌值的节点可以探测到死锁，可以避免多杀的问题。
> 
> 在边跟踪算法中死锁探测的基本原理是令牌值可以经由自己发出后回到自己，但是在多出度场景下采用单令牌值设计时可能出现死锁环路中最大的令牌值并不属于这个环路中的任何一个节点的情况，此情况下将检测不到死锁，该场景称为"环外污染"，因此 LCL 死锁检测方案引入了"路径深度"概念，每个节点维护一个路径深度值，在环路中的节点的路径深度值随时间推移可以无限增长，而不在环路中也不被环路中节点所触达的节点的路径深度值存在增长上限，约束节点只能接受路径深度至少和自己一样大的节点传递的令牌来避免"环外污染"，并通过定期清理节点上当前的令牌值来消除在算法运行早期阶段已经出现的"环外污染"，由此保证算法工作在多出度下的正确性。
> 
> 具体实现
> 当一个事务 A 遇到加行锁失败时，事务 A 在等待行锁解开的同时，会获取持有行锁的事务 B 的 ID，并创建出一个死锁检测节点 a（下文称为 Detector(a)），为 Detector(a) 记录到事务 B 的 Detector(b) 的单向依赖关系。
> 
> 每个节点要维护以下状态：
> 
> 当一个 Detector 节点被建出时生成两个令牌状态，一个公共令牌值（public label），一个私有令牌值（private label），它根据自己的优先级生成一个全局唯一性令牌（优先级越高的节点，令牌值越大），并用其初始化两个令牌值，并同时生成一个初始为 0 的深度值 lclv ((Lock Chain Length)。
> 
> 每一个 Detector 节点都维护一个依赖列表，列表中记录了依赖的其他节点的网络位置信息。
> 
> 从时间轴划分，每 1.4s 划分为一个 LCL 周期。
> 
> 在每个周期开始的时候，每个节点重置自己的 public label 为自己的 private label。
> 
> LCL 周期的前 700ms 称为 LCLP 周期（Lock Chain Length Proliferating），每个节点在该周期中定期将自己的状态的 lclv 值发送给依赖列表中的所有下游节点，每个节点在接收到上游节点发送来的 lclv 值后，将自己的 lclv 值更新为 max(lclv, received_lclv + 1)。
> 
> LCL 周期的后 700ms 称为 LCLS 周期（Lock Chain Length Spreading），每个节点在该周期中定期将自己的状态的 { lclv, public label } 发送给依赖列表中的所有下游节点，每个节点在接收到上游节点发送来的值后，若其 lclv 值不小于自己当前的 lclv 值，则更新自己的 public label 为 min(public label, received public label)，更新自己的 lclv 值为 received lclv。
> 
> 检测到死锁：当一个节点收到的 public label 是自己的 private lavel 时，它就发现了死锁。
> 
> 死锁过程的详细介绍，请参见 LCL: A Lock Chain Length-based Distributed Algorithm for Deadlock Detection and Resolution。
> 
> 视图
> 视图 __all_virtual_deadlock_event_history 记录了所有发生过的死锁事件以及参与这些事件的事务，并注明了在一个死锁事件中哪个事务最终被 kill 掉。
> 
[锁机制\-OceanBase 数据库 \-OceanBase文档中心\-分布式数据库使用文档](https://www.oceanbase.com/docs/community-observer-cn-10000000000902010)

[分布式 死锁 检测技术 LCL: A Lock Chain Length\-based Distributed Algorithm for Deadlock Detection and Resolution \- Google Search](https://www.google.com/search?q=%E5%88%86%E5%B8%83%E5%BC%8F+%E6%AD%BB%E9%94%81+%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF+LCL%3A+A+Lock+Chain+Length-based+Distributed+Algorithm+for+Deadlock+Detection+and+Resolution&newwindow=1&sxsrf=APwXEdeIDESqE80KzFstKxAeIQbfbq6HdA%3A1685375431195&ei=x8l0ZKLIC4OohwPompCwBg&ved=0ahUKEwjix47f8Jr_AhUD1GEKHWgNBGYQ4dUDCA8&uact=5&oq=%E5%88%86%E5%B8%83%E5%BC%8F+%E6%AD%BB%E9%94%81+%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF+LCL%3A+A+Lock+Chain+Length-based+Distributed+Algorithm+for+Deadlock+Detection+and+Resolution&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAEyBQghEKABOggIABCiBBCwA0oECEEYAVC4AVjgA2CMBmgBcAB4AIABjgGIAY4BkgEDMC4xmAEAoAEBoAECwAEByAEF&sclient=gws-wiz-serp)