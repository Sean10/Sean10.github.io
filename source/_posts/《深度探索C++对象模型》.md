---
title: 《深度探索C++对象模型》Note
date: 2018-02-08 14:00:07
tags: [C++]
categories: [专业]
---

static initialization保证了在main函数执行以前已经实例化类。

不过实际依赖于开发环境。

<!--more-->

译者推荐阅读一、三、四章

似乎<<不推荐作为类的成员函数，会由于左操作数是该实例而导致ostream只能是第二个参数，不过这本书中屡屡都是作为成员函数使用的，而且依旧是正常使用，这个疑问保留。（或许inline具有使其为非成员函数的功能？）

```c++
Sales_item item;
item << cout;

似乎会变成这样，但是书里还是正常的。
```

泛型 就是 参数化吗？

不定长参数如何参数化？书上那个看不太懂


###### 简单对象模型

members 不放在object中的意思是什么？不是member本就是实例化后存储在其他位置，内部成员函数才在编译后就被分配了一个空间吗

噢噢，一开始被分配的空间只是一个指向成员的指针空间，实际成员空间在外面分配

###### 表格驱动对象模型

数据成员表，成员函数表

对象内存储指向这两个表的指针

###### c++对象模型

非静态数据成员存储在对象中，静态存储在堆区。

主要优点是空间和时间存取的速度，不过实际上性能优点如何知晓？只是通过指针来访问，效率的影响有多少呢？

似乎上面那个表格驱动模型，因只存储了指针地址，所以修改了成员函数代码时，无需重新编译其他的应用程序代码，不过付出了时间和效率上的代价

虚继承有些忘记了

编译器会在派生类B的实例中保存一个A的实例，然后在B中加入一个变量，这个变量是A的实例在实际B实例中的偏移量，实际上B中并不直接保存offset的值，而是保存的一个指针，这个指针指向一个表vbtable，vbtable表中保存着所有虚继承的基类在实例中的offset值，多个B的实例共享这个表，每个实例有个单独的指针指向这个表，这样就很好理解为什么多了4个字节了。用代码表示就像下面这样。

这个offset的作用是什么不太理解，有个指针地址不就已经能访问这个对象了吗？

向前预览(lookahead)？

编译器应该是能够做到经过unparser工具处理后，可以还原原本使用的关键词的。（来自cfront 中遭遇过的bug)

```
struct mumble {
	char pc[1];
}
```

这种通过malloc来分配的可变数组为什么违背了c++的规范呢，成为c++的陷阱？




未完待续
