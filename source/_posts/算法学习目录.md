---
title: 算法学习目录
date: 2018-03-05 22:44:08
updated:
tags: [算法]
categories: [算法]
---

快排、归并、二分

<!--more-->

# 数组

## 双指针法

http://chocoluffy.com/2016/12/04/%E6%B5%85%E6%9E%90%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98-two-pointer%E7%9A%84%E8%BF%90%E7%94%A8/

# 表:
## 双重链接表

## 正交表

# 树:

## 二叉树
### 平衡二叉树
#### AVL树

## 自由树
## 有向树
## 无穷性引理
## 树的枚举
## 通路长度

# 图

## 有向图

### 有向无环图
#### 拓扑排序

我们都知道对于有向图进行拓扑排序可以判断是否存在环。

对于有向图的拓扑排序，大家都知道的kahn算法：

计算图中所有点的入度，把入度为0的点加入栈
如果栈非空：
取出栈顶顶点a，输出该顶点值，删除该顶点

从图中删除所有以a为起始点的边，如果删除的边的另一个顶点入度为0，则把它入栈

如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列

## 邻接矩阵

## 邻接表

## 十字链表
### 舞蹈链算法

## BFS

BFS（显式用队列）
DFS（隐式用栈）（即递归）
当然，对于DFS，用递归可能会造成栈溢出，所以也可以更改为显示栈。

``` c++
	将（起始）首节点加入队列：
	q.push(head);
    标记首节点已经被访问：
	isvisited[head]=true;
    以下自动反应：
	while(!q.empty()){
    	int temp=q.front();
    	q.pop();
		访问temp，并标记temp已被访问过，将temp的子相关节点加入队列
		q.push(temp相关节点);
	}

```

## DFS
```
void dfs(int 当前状态)
	{
	      if(当前状态为边界状态)
	      {
	        记录或输出
	        return;
	      }
	      for(i=0;i<n;i++)		//横向遍历解答树所有子节点
	     {
	           //扩展出一个子状态。
	           修改了全局变量
	           if(子状态满足约束条件)
	            {
	              dfs(子状态)
	           }
	            恢复全局变量//回溯部分
	        }
	}
```

转换 为 迭代时

### 尾递归



### dijkstra单源最短路径算法

### Prim最小生成树算法



每个阶段只有一个状态->递推；
每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；
而不管之前这个状态是如何得到的这个性质叫做无后效性。

# 动态规划

## 数字三角形问题，

由底向上，才算是每个阶段的最优状态

## 最长上升子序列(LIS)

究竟怎么由状态转移方程写成代码？

## 水库抽样算法
```
/*
  S has items to sample, R will contain the result
*/
ReservoirSample(S[1..n], R[1..k])
  // fill the reservoir array
  for i = 1 to k
      R[i] := S[i]

  // replace elements with gradually decreasing probability
  for i = k+1 to n
    j := random(1, i)   // important: inclusive range
    if j <= k
        R[j] := S[i]
```

## 滑动窗口问题，substring
``` c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> pv(26, 0), sv(26, 0), ans;
        if (s.size() < p.size())
            return ans;

        for (int i = 0;i < p.size(); i++)
        {
            ++pv[p[i] - 'a'];
            ++sv[s[i] - 'a'];
        }

        if (pv == sv)
            ans.push_back(0);

        for (int i = p.size(); i < s.size(); i++)
        {
            ++ sv[s[i] - 'a'];
            -- sv[s[i - p.size()] - 'a'];
            if (sv == pv)
                ans.push_back(i - p.size() + 1);
        }
        return ans;


    }
};

```

## 动态规划 最长公共子序列
``` c++
class Solution {
public:
    int LongCommonSubsequence(string word1, string word2) {
        vector<vector<int>> dp(word1.size()+1, vector<int>(word2.size()+1, 0));

        for (int i = 0;i <= word1.size(); i++)
            dp[i][0] = 0;

        for (int j = 0;j <= word2.size(); j++)
            dp[0][j] = 0;

        for (int i = 1;i <= word1.size(); i++)
            for (int j = 1;j <= word2.size(); j++)
            {
                if (word1[i-1] == word2[j-1])
                    dp[i][j] = 1 + dp[i-1][j-1];
                else
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
		return dp[word1.size()][word2.size()];
    }
};
```
