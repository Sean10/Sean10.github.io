---
title: 算法学习目录
date: 2018-03-05 22:44:08
updated:
tags: [算法]
categories: [算法]
---

快排、归并、二分

<!--more-->

# 数组

####  原地转置

不过这个是对一维数组的操作，暂时没想到对二维非方阵数组，除了不停的resize以外的方法。
```
int getNext(int i, int m, int n)
{
    return (i%n)*m + i/n;
}
 
/* 前驱 */
int getPre(int i, int m, int n)
{
    return (i%m)*n + i/m;
}
 
/* 处理以下标i为起点的环 */
void movedata(int *mtx, int i, int m, int n)
{
    int temp = mtx[i];  // 暂存
    int cur = i;       // 当前下标
    int pre = getPre(cur, m, n);
    while(pre != i)
    {
        mtx[cur] = mtx[pre];
        cur = pre;
        pre = getPre(cur, m, n);
    }
    mtx[cur] = temp;
}
 
/* 转置，即循环处理所有环 */
void transpose(int *mtx, int m, int n)
{
    for(int i=0; i<m*n; ++i)
    {
        int next = getNext(i, m, n);
        while(next > i) // 若存在后继小于i说明重复
            next = getNext(next, m, n);
        if(next == i)   // 处理当前环 
            movedata(mtx, i, m, n);
    }
}
 
/* 输出矩阵 */
void print(int *mtx, int m, int n)
{
    for(int i=0; i<m*n; ++i)
    {
        if((i+1)%n == 0)
            cout << mtx[i] << "\n";
        else
            cout << mtx[i] << " ";
    }
}
```

## 双指针法

http://chocoluffy.com/2016/12/04/%E6%B5%85%E6%9E%90%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98-two-pointer%E7%9A%84%E8%BF%90%E7%94%A8/

# 表:
## 双重链接表

## 正交表

# 树:

## 二叉树
### 平衡二叉树
#### AVL树

## 自由树
## 有向树
## 无穷性引理
## 树的枚举
## 通路长度

# 图

## 有向图

### 有向无环图
#### 拓扑排序

我们都知道对于有向图进行拓扑排序可以判断是否存在环。

对于有向图的拓扑排序，大家都知道的kahn算法：

计算图中所有点的入度，把入度为0的点加入栈
如果栈非空：
取出栈顶顶点a，输出该顶点值，删除该顶点

从图中删除所有以a为起始点的边，如果删除的边的另一个顶点入度为0，则把它入栈

如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列

##### dfs

##### bfs

## 邻接矩阵

## 邻接表

## 十字链表
### 舞蹈链算法

## BFS

BFS（显式用队列）
DFS（隐式用栈）（即递归）
当然，对于DFS，用递归可能会造成栈溢出，所以也可以更改为显示栈。

``` c++
	将（起始）首节点加入队列：
	q.push(head);
    标记首节点已经被访问：
	isvisited[head]=true;
    以下自动反应：
	while(!q.empty()){
    	int temp=q.front();
    	q.pop();
		访问temp，并标记temp已被访问过，将temp的子相关节点加入队列
		q.push(temp相关节点);
	}

```

## DFS
```
void dfs(int 当前状态)
	{
	      if(当前状态为边界状态)
	      {
	        记录或输出
	        return;
	      }
	      for(i=0;i<n;i++)		//横向遍历解答树所有子节点
	     {
	           //扩展出一个子状态。
	           修改了全局变量
	           if(子状态满足约束条件)
	            {
	              dfs(子状态)
	           }
	            恢复全局变量//回溯部分
	        }
	}
```

转换 为 迭代时

### 尾递归

非尾递归:下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。

尾递归的精髓在于往内进行下一层解析的时候，这一层函数执行完了没卵用了，编译器一想，你都没卵用了我把你参数改改也没事啊，改了之后发现，哟呵这不是你儿子吗，那你爷俩就用这一块地儿好了。所以空间复杂度是O(1)。

尾递归优化主要看语言编译器的支持吧？python\java中没有尾递归优化，因此鼓励用迭代的方式来实现。「似乎说是为了抛出异常时有完整的Stack trace」

好像C中并没有规定需要尾递归优化，默认并不开启，也不推荐写尾递归，如果代码需要跨平台（那就不要写了）

似乎Erlang更推荐。Erlang的虚拟机会进行优化。

是不是应该写个例子出来？

尾递归优化主要解决内存占用问题，从O(n)转为O(1)



### dijkstra单源最短路径算法

### Prim最小生成树算法



每个阶段只有一个状态->递推；
每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；
而不管之前这个状态是如何得到的这个性质叫做无后效性。

# 动态规划

## 数字三角形问题，

由底向上，才算是每个阶段的最优状态

## 最长上升子序列(LIS)

究竟怎么由状态转移方程写成代码？

## 水库抽样算法
```
/*
  S has items to sample, R will contain the result
*/
ReservoirSample(S[1..n], R[1..k])
  // fill the reservoir array
  for i = 1 to k
      R[i] := S[i]

  // replace elements with gradually decreasing probability
  for i = k+1 to n
    j := random(1, i)   // important: inclusive range
    if j <= k
        R[j] := S[i]
```

## 滑动窗口问题，substring
``` c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> pv(26, 0), sv(26, 0), ans;
        if (s.size() < p.size())
            return ans;

        for (int i = 0;i < p.size(); i++)
        {
            ++pv[p[i] - 'a'];
            ++sv[s[i] - 'a'];
        }

        if (pv == sv)
            ans.push_back(0);

        for (int i = p.size(); i < s.size(); i++)
        {
            ++ sv[s[i] - 'a'];
            -- sv[s[i - p.size()] - 'a'];
            if (sv == pv)
                ans.push_back(i - p.size() + 1);
        }
        return ans;


    }
};

```

### `leetcode` 样题:
* 1562

## 动态规划 最长公共子序列
``` c++
class Solution {
public:
    int LongCommonSubsequence(string word1, string word2) {
        vector<vector<int>> dp(word1.size()+1, vector<int>(word2.size()+1, 0));

        for (int i = 0;i <= word1.size(); i++)
            dp[i][0] = 0;

        for (int j = 0;j <= word2.size(); j++)
            dp[0][j] = 0;

        for (int i = 1;i <= word1.size(); i++)
            for (int j = 1;j <= word2.size(); j++)
            {
                if (word1[i-1] == word2[j-1])
                    dp[i][j] = 1 + dp[i-1][j-1];
                else
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
		return dp[word1.size()][word2.size()];
    }
};
```

