---
title: 数组取数——限时排序
tags: [数据结构]
date: 2016-01-07 19:47:00
categories: 算法
---

总时间限制: 1000ms 内存限制: 65536kB
__描述__
有一个整数数组A和一个目标整数T，希望从A中没有放回地取出两个数，使得两个数之差等于T。请问有多少种不同的取法？（取出的两个数分别相等时视为同一种取法）

__输入__
输入由两行组成。第一行为两个整型范围内的整数N和T，N为数组长度（N的范围是[2,100000]），T为目标整数。第二行为N个整数，表示数组A，每个整数的范围是[-1000000,1000000]。
__输出__
A中取出两个数之差为T的不同的取法的数目。
__样例输入__
```
6 1
1 3 2 1 2 2
```
__样例输出__
```
2
```

这道题式始终WA和TLE中徘徊，不知道怎么修改了暂时。
```
#include <cstdio>
#include <cstdlib>
#include <cmath>

#define N 100005
typedef struct node{
    int x,y;
}Node;

Node num[N];
int start = 0;

int cmp(const void* a,const void *b){
    return *(int*)a-*(int*)b;
}

void func(int data[],int n,int T){
    int flag ;
    for(int i = n-1;i > 0;i--){
        int left = 0,right = i;
        for(int j = (left+right)/2;j >= left && j <= right && left <= right;j = (left+right)/2){
            if(data[i]-data[j] == T){
                flag = 0;
                for(int k = 0;k < start;k++){
                    if((data[i] == num[k].x && data[j] == num[k].y)
                       || (data[i] == num[k].y && data[j] == num[k].x))
                        flag = 1;
                }
                if(flag == 0){
                    num[start].x = data[i];
                    num[start++].y = data[j];
                }
                break;
            }
            else if(data[i]-data[j] > T){
                left = j+1;
                right = (j+1+right)/2;
            }
            else{
                right = j-1;
            }
        }
    }
}

int main(){
    //freopen("in.txt","r",stdin);
    int data[N];

    int n ,T;
    scanf("%d%d",&n,&T);
    if(T < 0)
        T= -T;
    for(int i = 0;i < n;i++){
        scanf("%d",&data[i]);
    }
    qsort(data,n,sizeof(int),cmp);

    func(data,n,T);
    printf("%d\n",start);

    return 0;
}
```