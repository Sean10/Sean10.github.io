---
title: 距离排序
tags: [排序]
date: 2016-01-06 16:56:00
categories: 算法
---

总时间限制: 1000ms 内存限制: 65536kB
__描述__
给出三维空间中的n个点（不超过10个）,求出n个点两两之间的距离,并按距离由大到小依次输出两个点的坐标及它们之间的距离。
__输入__
输入包括两行，第一行包含一个整数n表示点的个数，第二行包含每个点的坐标(坐标都是整数)。点的坐标的范围是0到100，输入数据中不存在坐标相同的点。
__输出__
对于大小为n的输入数据，输出n*(n-1)/2行格式如下的距离信息：
(x1,y1,z1)-(x2,y2,z2)=距离
其中距离保留到数点后面2位。
(用cout输出时保留到小数点后2位的方法:cout<<fixed<<setprecision(2)<<x)
样例输入
```
4
0 0 0 1 0 0 1 1 0 1 1 1
```
样例输出
```
(0,0,0)-(1,1,1)=1.73
(0,0,0)-(1,1,0)=1.41
(1,0,0)-(1,1,1)=1.41
(0,0,0)-(1,0,0)=1.00
(1,0,0)-(1,1,0)=1.00
(1,1,0)-(1,1,1)=1.00
```

代码
```
#include <cstdio>
#include <cstdlib>
#include <cmath>

typedef struct point{
    int x,y,z;
}Point;

typedef struct data{
    int a,b;
    double len;
}Data;

int main(){
    //freopen("in.txt","r",stdin);
    int n;
    Point data[11];
    Data len[110];
    scanf("%d",&n);
    for(int i = 0;i < n;i++){
        scanf("%d%d%d",&data[i].x,&data[i].y,&data[i].z);
    }

    int start = 0;
    double length;
    int k;
    for(int i = 0;i < n-1;i++){
        for(int j = i+1;j < n;j++){
            length = sqrt((data[i].x-data[j].x)*(data[i].x-data[j].x)
                                    +(data[i].y-data[j].y)*(data[i].y-data[j].y)
                                    +(data[i].z-data[j].z)*(data[i].z-data[j].z));
            for(k = 0;k < start && length-len[k].len <= 1e-10;k++);
            for(int l = start;l > k;l--)
                len[l] = len[l-1];
            len[k].a = i;
            len[k].b = j;
            len[k].len = length;
            start++;
        }
    }

    for(int i = 0;i < start;i++){
        printf("(%d,%d,%d)-(%d,%d,%d)=%.2f\n",data[len[i].a].x,data[len[i].a].y,data[len[i].a].z,
                                            data[len[i].b].x,data[len[i].b].y,data[len[i].b].z,len[i].len);
    }

    return 0;
}
```